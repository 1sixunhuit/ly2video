#!/usr/bin/python

"""
xsc2beatmap - generates a beat map from an .xsc file
Copyright (C) 2013 Adam Spiers <music@adamspiers.org>

This program extracts markers from an .xsc file generated by the
"Transcribe!" software available at:

  http://seventhstring.com/xscribe/overview.html

and converts them into a beatmap file, whose format is described
in doc/beatmap-files.md.

Measures without beats will have the beats inserted via linear
interpolation, using the time signature of the previous bar.
Up-beats (anachrusis beats) will be treated as being in the time
signature of the first bar, which defaults to 4/4 if it doesn't
contain any beats.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

import re
import sys

def read_beats(filename):
    beat = 0
    measure = 0
    section = 0
    time_signature = (4, 4)
    start_time = None
    start_time_signature = None

    xsc = open(filename)
    in_section = False
    beats = []

    # We need to store anacrusis beats and then prepend them
    # back after everything else has processed, at which point
    # we'll know the time signature of the first full bar.
    anacrusis = []

    for line in xsc.readlines():
        if not in_section:
            if "SectionStart,Markers" in line:
                in_section = True
            continue

        if "SectionEnd,Markers" in line:
            break

        if "Howmany" in line:
            continue

        m = re.match('^([SMB]),(\d+),([01]),(\w*),(\d+),(\d+:\d+:\d+\.\d+)$', line)
        if not m:
            sys.stderr.write("Failed to parse line:\n" + line)
            sys.exit(1)

        marker_type, samples, auto, label, subdivision, timestamp = \
            m.groups()

        if label == "":
            label = "-"

        secs = timestamp_to_secs(timestamp)

        if start_time is None:
            start_time = secs

        if marker_type == 'B':
            if measure == 0:
                anacrusis.append((label, secs))
                continue
            else:
                beat += 1
        elif marker_type == 'M' or marker_type == 'S':
            if beats:
                previous_beat_num = beats[-1][3]
                if previous_beat_num == 1:
                    # No beats in the last bar, so interpolate
                    # based on last time signature
                    now         = secs
                    previous    = beats[-1][4]
                    num_beats   = time_signature[0]
                    beat_length = (now - previous) / float(num_beats)
                    for i in xrange(1, num_beats):
                        interpolated_secs = \
                            previous + i*beat_length
                        beats.append((str(i+1), section, measure, i+1,
                                      interpolated_secs))

            if beat <= 1:
                beat = time_signature[0]
            time_signature = (beat, 4) # FIXME: support other denominators
            if start_time_signature is None:
                start_time_signature = time_signature

            if marker_type == 'M':
                measure += 1
            else:
                section += 1
                measure = 1
            beat = 1
        else:
            sys.stderr.write("BUG: unexpected marker_type %s" % marker_type)
            sys.exit(1)

        beats.append((label, section, measure, beat, secs))

    xsc.close()

    start_beat = start_time_signature[0] - len(anacrusis) + 1
    i = 0
    for label, secs in anacrusis:
        beats.insert(i, (label, 0, 0, start_beat + i, secs))
        i += 1

    return start_time, beats

# def get_measure_tempos(beats):
#     tempos = { }
#     current_measure = None
#     prev_measure_start = None
#     beats_in_measure = 0
#     last_tempo = None
#     for i in xrange(len(beats)):
#         label, section, measure, beat, secs = beats[i]
#
#         if current_measure is None:
#             current_measure = (section, measure)
#             prev_measure_start = secs
#
#         if current_measure == (section, measure):
#             beats_in_measure += 1
#         else:
#             # We just started a new measure or section.
#             # current_measure still refers to the previous measure.
#             prev_measure_duration = secs - prev_measure_start
#             avg_beat_duration = prev_measure_duration / beats_in_measure
#             prev_measure_tempo = 60.0 / avg_beat_duration
#             if prev_measure_tempo != last_tempo:
#                 tempos[current_measure] = prev_measure_tempo
#             last_tempo = prev_measure_tempo
#
#             current_measure = (section, measure)
#             prev_measure_start = secs
#             beats_in_measure = 1
#
#     return tempos
#
# def show_beats_with_measure_tempos(beats):
#     prev_measure = None
#
#     tempos = get_measure_tempos(beats)
#
#     for label, section, measure, beat, secs in beats:
#         current_measure = (section, measure)
#         if prev_measure is None or prev_measure != current_measure:
#             if current_measure in tempos:
#                 print("tempo %3d %3d %.8f bpm" %
#                       (section, measure, tempos[current_measure]))
#
#         timestamp = secs_to_timestamp(secs)
#         print "%-5s %3d %3d %2d %s" % (label, section, measure, beat, timestamp)
#         prev_measure = current_measure

def get_beat_tempos(beats):
    tempos = [ ]
    prev_secs = None
    last_tempo = None
    for i in xrange(len(beats)):
        label, section, measure, beat, secs = beats[i]
        if prev_secs is not None:
            tempo = 60.0 / (secs - prev_secs)
            tempos.append(tempo)
        prev_secs = secs

    return tempos

def show_beats_with_beat_tempos(beats):
    tempos = get_beat_tempos(beats)

    for i in xrange(len(beats)):
        label, section, measure, beat, secs = beats[i]
        timestamp = secs_to_timestamp(secs)
        out = "%-5s %3d %3d %2d %16s 1 1" % \
              (label, section, measure, beat, timestamp)
        if i < len(tempos):
            out += "  %.8f" % tempos[i]
        print out

def timestamp_to_secs(timestamp):
    hours, mins, secs = timestamp.split(':')
    return (int(hours)*60 + int(mins))*60.0 + float(secs)

def secs_to_timestamp(secs):
    mins  = secs / 60
    secs  = secs % 60
    hours = mins / 60
    mins  = mins % 60
    secs  = "%.06f" % secs
    if secs[1] == '.':
        secs = '0' + secs
    return "%d:%02d:%s" % (hours, mins, secs)

def main():
    start_time, beats = read_beats(sys.argv[1])
    show_beats_with_beat_tempos(beats)

if __name__ == '__main__':
    main()
